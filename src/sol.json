{
  "value":"pragma solidity ^0.4.4;\r\n\r\n/**\r\n * @title Contract for object that have an owner\r\n */\r\ncontract Owned {\r\n\r\n    /**\r\n     * Contract owner address\r\n     */\r\n    address public owner;\r\n\r\n    /**\r\n     * @dev Delegate contract to another person\r\n     * @param _owner New owner address\r\n     */\r\n    function setOwner(address _owner) onlyOwner {\r\n        owner = _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Owner check modifier\r\n     */\r\n    modifier onlyOwner { if (msg.sender != owner) throw; _; }\r\n}\r\n\r\n/**\r\n * @title Common pattern for destroyable contracts\r\n */\r\ncontract Destroyable {\r\n\r\n    address public hammer;\r\n\r\n    /**\r\n     * @dev Hammer setter\r\n     * @param _hammer New hammer address\r\n     */\r\n    function setHammer(address _hammer) onlyHammer {\r\n        hammer = _hammer;\r\n    }\r\n\r\n    /**\r\n     * @dev Destroy contract and scrub a data\r\n     * @notice Only hammer can call it\r\n     */\r\n    function destroy() onlyHammer {\r\n        suicide(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Hammer check modifier\r\n     */\r\n    modifier onlyHammer { if (msg.sender != hammer) throw; _; }\r\n}\r\n\r\n/**\r\n * @title Generic owned destroyable contract\r\n */\r\ncontract Object is Owned, Destroyable {\r\n\r\n    function Object() {\r\n        owner  = msg.sender;\r\n        hammer = msg.sender;\r\n    }\r\n}\r\n\r\n// Standard token interface (ERC 20)\r\n// https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20 {\r\n\r\n    // Functions:\r\n    /// @return total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool);\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256);\r\n\r\n    // Events:\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/**\r\n * @title Token contract represents any asset in digital economy\r\n */\r\ncontract Token is Object, ERC20 {\r\n\r\n    /* Short description of token */\r\n    string public name;\r\n    string public symbol;\r\n\r\n    /* Total count of tokens exist */\r\n    uint256 public totalSupply;\r\n\r\n    /* Fixed point position */\r\n    uint8 public decimals;\r\n\r\n    /* Token approvement system */\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping(address => uint256)) allowances;\r\n\r\n    /* Token constructor */\r\n    function Token(string _name, string _symbol, uint8 _decimals, uint256 _count) {\r\n        name        = _name;\r\n        symbol      = _symbol;\r\n        decimals    = _decimals;\r\n        totalSupply = _count;\r\n        balances[msg.sender] = _count;\r\n    }\r\n\r\n    /**\r\n     * @dev Get balance of plain address\r\n     * @param _owner is a target address\r\n     * @return amount of tokens on balance\r\n     */\r\n    function balanceOf(address _owner) constant returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Take allowed tokens\r\n     * @param _owner The address of the account owning tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @return Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(address _owner, address _spender) constant returns (uint256) {\r\n        return allowances[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer self tokens to given address\r\n     * @param _to destination address\r\n     * @param _value amount of token values to send\r\n     * @notice `_value` tokens will be sended to `_to`\r\n     * @return `true` when transfer done\r\n     */\r\n    function transfer(address _to, uint256 _value) returns (bool) {\r\n        if (balances[msg.sender] >= _value) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to]        += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer with approvement mechainsm\r\n     * @param _from source address, `_value` tokens shold be approved for `sender`\r\n     * @param _to destination address\r\n     * @param _value amount of token values to send\r\n     * @notice from `_from` will be sended `_value` tokens to `_to`\r\n     * @return `true` when transfer is done\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\n        var avail = allowances[_from][msg.sender] > balances[_from] ? balances[_from] : allowances[_from][msg.sender];\r\n        if (avail >= _value) {\r\n            allowances[_from][msg.sender] -= _value;\r\n            balances[_from] -= _value;\r\n            balances[_to]   += _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Give to target address ability for self token manipulation without sending\r\n     * @param _spender target address (future requester)\r\n     * @param _value amount of token values for approving\r\n     */\r\n    function approve(address _spender, uint256 _value) returns (bool) {\r\n        allowances[msg.sender][_spender] += _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Reset count of tokens approved for given address\r\n     * @param _spender target address (future requester)\r\n     */\r\n    function unapprove(address _spender) {\r\n        allowances[msg.sender][_spender] = 0;\r\n    }\r\n}\r\n\r\ncontract TokenEmission is Token {\r\n\r\n    function TokenEmission(string _name, string _symbol, uint8 _decimals, uint _start_count)\r\n    Token(_name, _symbol, _decimals, _start_count){}\r\n\r\n    /**\r\n     * @dev Token emission\r\n     * @param _value amount of token values to emit\r\n     * @notice owner balance will be increased by `_value`\r\n     */\r\n    function emission(uint _value) onlyOwner {\r\n        // Overflow check\r\n        if (_value + totalSupply < totalSupply) {\r\n            throw;\r\n        }\r\n\r\n        totalSupply     += _value;\r\n        balances[owner] += _value;\r\n    }\r\n\r\n    /**\r\n     * @dev Burn the token values from sender balance and from total\r\n     * @param _value amount of token values for burn\r\n     * @notice sender balance will be decreased by `_value`\r\n     */\r\n    function burn(uint _value) {\r\n        if (balances[msg.sender] >= _value) {\r\n            balances[msg.sender] -= _value;\r\n            totalSupply      -= _value;\r\n        }\r\n    }\r\n}\r\n\r\ncontract GoodPoint is TokenEmission {\r\n\r\n    function GoodPoint(uint _start_count)\r\n    TokenEmission(\"GoodPoint\", \"GP\", 0, _start_count);\r\n}\r\n\r\ncontract BadPoint is TokenEmission {\r\n\r\n    function BadPoint(uint _start_count)\r\n    TokenEmission(\"BadPoint\", \"BP\", 0, _start_count);\r\n}\r\n\r\ncontract DateTime {\r\n\r\n    /*\r\n     *  Date and Time utilities for ethereum contracts\r\n     *\r\n     */\r\n    struct DateTime {\r\n    uint16 year;\r\n    uint8 month;\r\n    uint8 day;\r\n    uint8 hour;\r\n    uint8 minute;\r\n    uint8 second;\r\n    uint8 weekday;\r\n    }\r\n\r\n    uint constant DAY_IN_SECONDS = 86400;\r\n    uint constant YEAR_IN_SECONDS = 31536000;\r\n    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n    uint constant HOUR_IN_SECONDS = 3600;\r\n    uint constant MINUTE_IN_SECONDS = 60;\r\n\r\n    uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n    function isLeapYear(uint16 year) constant returns (bool) {\r\n        if (year % 4 != 0) {\r\n            return false;\r\n        }\r\n        if (year % 100 != 0) {\r\n            return true;\r\n        }\r\n        if (year % 400 != 0) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function leapYearsBefore(uint year) constant returns (uint) {\r\n        year -= 1;\r\n        return year / 4 - year / 100 + year / 400;\r\n    }\r\n\r\n    function getDaysInMonth(uint8 month, uint16 year) constant returns (uint8) {\r\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n            return 31;\r\n        }\r\n        else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n            return 30;\r\n        }\r\n        else if (isLeapYear(year)) {\r\n            return 29;\r\n        }\r\n        else {\r\n            return 28;\r\n        }\r\n    }\r\n\r\n    function parseTimestamp(uint timestamp) internal returns (DateTime dt) {\r\n        uint secondsAccountedFor = 0;\r\n        uint buf;\r\n        uint8 i;\r\n\r\n        // Year\r\n        dt.year = getYear(timestamp);\r\n        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n        // Month\r\n        uint secondsInMonth;\r\n        for (i = 1; i <= 12; i++) {\r\n            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n            if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                dt.month = i;\r\n                break;\r\n            }\r\n            secondsAccountedFor += secondsInMonth;\r\n        }\r\n\r\n        // Day\r\n        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                dt.day = i;\r\n                break;\r\n            }\r\n            secondsAccountedFor += DAY_IN_SECONDS;\r\n        }\r\n\r\n        // Hour\r\n        dt.hour = getHour(timestamp);\r\n\r\n        // Minute\r\n        dt.minute = getMinute(timestamp);\r\n\r\n        // Second\r\n        dt.second = getSecond(timestamp);\r\n\r\n        // Day of week.\r\n        dt.weekday = getWeekday(timestamp);\r\n    }\r\n\r\n    function getYear(uint timestamp) constant returns (uint16) {\r\n        uint secondsAccountedFor = 0;\r\n        uint16 year;\r\n        uint numLeapYears;\r\n\r\n        // Year\r\n        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n        while (secondsAccountedFor > timestamp) {\r\n            if (isLeapYear(uint16(year - 1))) {\r\n                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n            }\r\n            else {\r\n                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n            }\r\n            year -= 1;\r\n        }\r\n        return year;\r\n    }\r\n\r\n    function getMonth(uint timestamp) constant returns (uint8) {\r\n        return parseTimestamp(timestamp).month;\r\n    }\r\n\r\n    function getDay(uint timestamp) constant returns (uint8) {\r\n        return parseTimestamp(timestamp).day;\r\n    }\r\n\r\n    function getHour(uint timestamp) constant returns (uint8) {\r\n        return uint8((timestamp / 60 / 60) % 24);\r\n    }\r\n\r\n    function getMinute(uint timestamp) constant returns (uint8) {\r\n        return uint8((timestamp / 60) % 60);\r\n    }\r\n\r\n    function getSecond(uint timestamp) constant returns (uint8) {\r\n        return uint8(timestamp % 60);\r\n    }\r\n\r\n    function getWeekday(uint timestamp) constant returns (uint8) {\r\n        return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day) constant returns (uint timestamp) {\r\n        return toTimestamp(year, month, day, 0, 0, 0);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) constant returns (uint timestamp) {\r\n        return toTimestamp(year, month, day, hour, 0, 0);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) constant returns (uint timestamp) {\r\n        return toTimestamp(year, month, day, hour, minute, 0);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) constant returns (uint timestamp) {\r\n        uint16 i;\r\n\r\n        // Year\r\n        for (i = ORIGIN_YEAR; i < year; i++) {\r\n            if (isLeapYear(i)) {\r\n                timestamp += LEAP_YEAR_IN_SECONDS;\r\n            }\r\n            else {\r\n                timestamp += YEAR_IN_SECONDS;\r\n            }\r\n        }\r\n\r\n        // Month\r\n        uint8[12] memory monthDayCounts;\r\n        monthDayCounts[0] = 31;\r\n        if (isLeapYear(year)) {\r\n            monthDayCounts[1] = 29;\r\n        }\r\n        else {\r\n            monthDayCounts[1] = 28;\r\n        }\r\n        monthDayCounts[2] = 31;\r\n        monthDayCounts[3] = 30;\r\n        monthDayCounts[4] = 31;\r\n        monthDayCounts[5] = 30;\r\n        monthDayCounts[6] = 31;\r\n        monthDayCounts[7] = 31;\r\n        monthDayCounts[8] = 30;\r\n        monthDayCounts[9] = 31;\r\n        monthDayCounts[10] = 30;\r\n        monthDayCounts[11] = 31;\r\n\r\n        for (i = 1; i < month; i++) {\r\n            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\r\n        }\r\n\r\n        // Day\r\n        timestamp += DAY_IN_SECONDS * (day - 1);\r\n\r\n        // Hour\r\n        timestamp += HOUR_IN_SECONDS * (hour);\r\n\r\n        // Minute\r\n        timestamp += MINUTE_IN_SECONDS * (minute);\r\n\r\n        // Second\r\n        timestamp += second;\r\n\r\n        return timestamp;\r\n    }\r\n}\r\n\r\ncontract Reports is Owned {\r\n\r\n    event ReportCreatedOk(address creator, uint time);\r\n    event ReportCreateError(address creator, uint time);\r\n    event MidnightEvent();\r\n\r\n    address oracle;\r\n    address[] employees;\r\n    address[] dayReports;\r\n    uint currentYear;\r\n    uint currentMonth;\r\n    uint currentDay;\r\n    GoodPoint goodPoints;\r\n    BadPoint badPoints;\r\n    DateTime dateUtils;\r\n\r\n    function Reports(address _oracle, address[] _employees, uint workDaysLeft) {\r\n        oracle = _oracle;\r\n        employees = _employees;\r\n        if (_employees.length > 0 && workDaysLeft > 0) {\r\n            goodPoints = GoodPoint(_employees.length * workDaysLeft);\r\n            badPoints = BadPoint(_employees.length * workDaysLeft);\r\n        }\r\n        dateUtils = new DateTime();\r\n        currentYear = dateUtils.getYear(now);\r\n        currentMonth = dateUtils.getMonth(now);\r\n        currentDay = dateUtils.getDay(now);\r\n    }\r\n\r\n    function hire(address newEmployee, uint workDaysLeft) onlyOwner {\r\n        employees.push(newEmployee);\r\n        goodPoints.emission(workDaysLeft);\r\n        badPoints.emission(workDaysLeft);\r\n    }\r\n\r\n    function fire(address oldEmployee, uint workDaysLeft) onlyOwner {\r\n        for (uint i = 0; i < employees.length; i++) {\r\n            if (employees[i] == oldEmployee) {\r\n                delete employees[i];\r\n                goodPoints.burn(workDaysLeft);\r\n                badPoints.burn(workDaysLeft);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function createReport(address creator, uint createTime) onlyOracle {\r\n        if (dateUtils.getYear(createTime) == dateUtils.getYear(now)\r\n        && dateUtils.getMonth(createTime) == dateUtils.getMonth(now)\r\n        && dateUtils.getDay(createTime) == dateUtils.getDay(now)) {\r\n            for (uint i = 0; i < employees.length; i++) {\r\n                if (employees[i] == creator) {\r\n                    if (goodPoints.transfer(creator, 1)) {\r\n                        dayReports.push(creator);\r\n                        ReportCreatedOk(creator, createTime);\r\n                    } else {\r\n                        ReportCreateError(creator, createTime);\r\n                        throw;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function midnight() onlyOracle {\r\n        uint year = dateUtils.getYear(now);\r\n        uint month = dateUtils.getMonth(now);\r\n        uint day = dateUtils.getDay(now);\r\n        if (currentYear != year || currentMonth != month || currentDay != day) {\r\n            currentYear = year;\r\n            currentMonth = month;\r\n            currentDay = day;\r\n            for (uint i = 0; i < employees.length; i++) {\r\n                bool founded = false;\r\n                for (uint j = 0; j < dayReports.length; j++) {\r\n                    if (employees[i] == dayReports[j]) {\r\n                        founded = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!founded) {\r\n                    if (badPoints.transfer(employees[i], 1)) {}\r\n                }\r\n            }\r\n            MidnightEvent();\r\n        }\r\n    }\r\n\r\n    modifier onlyOracle() {\r\n        if (msg.sender != oracle) {\r\n            _;\r\n        }\r\n    }\r\n}"
}